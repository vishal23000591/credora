export class TOTP{static async generate(e,t){const r={digits:6,algorithm:"SHA-1",encoding:"hex",period:30,timestamp:Date.now(),explicitZeroPad:!1,...t},a=Math.floor(r.timestamp/1e3),i=TOTP.dec2hex(Math.floor(a/r.period)).padStart(16,"0"),o="hex"===r.encoding?TOTP.base32ToBuffer(e):TOTP.asciiToBuffer(e),n=await TOTP.crypto.importKey("raw",o,{name:"HMAC",hash:{name:r.algorithm}},!1,["sign"]),c=await TOTP.crypto.sign("HMAC",n,TOTP.hex2buf(i)),s=TOTP.buf2hex(c),h=2*TOTP.hex2dec(s.slice(-1)),T=(2147483647&TOTP.hex2dec(s.slice(h,h+8))).toString().slice(-r.digits),d=r.explicitZeroPad?T.padStart(r.digits,"0"):T,l=1e3*r.period;return{otp:d,expires:Math.ceil((r.timestamp+1)/l)*l}}static hex2dec(e){return parseInt(e,16)}static dec2hex(e){return(e<15.5?"0":"")+Math.round(e).toString(16)}static base32ToBuffer(e){let t=(e=e.toUpperCase()).length;for(;61===e.charCodeAt(t-1);)t--;const r=new Uint8Array(5*t/8);let a=0,i=0,o=0;for(let n=0;n<t;n++){const t=TOTP.base32[e.charCodeAt(n)];if(void 0===t)throw new Error("Invalid base32 character in key");a=a<<5|t,i+=5,i>=8&&(r[o++]=a>>>(i-=8))}return r.buffer}static asciiToBuffer(e){const t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t.buffer}static hex2buf(e){const t=new Uint8Array(e.length/2);for(let r=0,a=0;r<e.length;r+=2,a++)t[a]=TOTP.hex2dec(e.slice(r,r+2));return t.buffer}static buf2hex(e){return[...new Uint8Array(e)].map(e=>e.toString(16).padStart(2,"0")).join("")}static crypto=(globalThis.crypto||require("node:crypto").webcrypto).subtle;static base32={50:26,51:27,52:28,53:29,54:30,55:31,65:0,66:1,67:2,68:3,69:4,70:5,71:6,72:7,73:8,74:9,75:10,76:11,77:12,78:13,79:14,80:15,81:16,82:17,83:18,84:19,85:20,86:21,87:22,88:23,89:24,90:25}}